package compiler

import (
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/dsxg666/snakecoin/vm/lexer"
	"github.com/dsxg666/snakecoin/vm/opcode"
	"github.com/dsxg666/snakecoin/vm/token"
)

type Compiler struct {
	l         *lexer.Lexer   // lexer
	token     token.Token    // current token
	nextToken token.Token    // next token
	bytecode  []byte         // generated bytecode
	labels    map[string]int // holder for labels
	fixups    map[int]string // holder for fixups
}

func New(l *lexer.Lexer) *Compiler {
	c := &Compiler{l: l}
	c.labels = make(map[string]int)
	c.fixups = make(map[int]string)
	c.readToken()
	c.readToken()
	return c
}

func (c *Compiler) readToken() {
	c.token = c.nextToken
	c.nextToken = c.l.NextToken()
}

// isRegister returns true if the given string has a register ID
func (c *Compiler) isRegister(input string) bool {
	return strings.HasPrefix(input, "#")
}

// getRegister converts a register string "#2" to an integer 2.
func (c *Compiler) getRegister(input string) byte {

	num := strings.TrimPrefix(input, "#")

	i, err := strconv.Atoi(num)
	if err != nil {
		panic(err)
	}

	if (i >= 0) && (i <= 15) {
		return byte(i)
	}

	fmt.Printf("Register out of bounds: #%s\n", input)
	os.Exit(1)
	return 0
}

// Dump process the stream of tokens from the lexer and shows the structure
// of the program.
func (c *Compiler) Dump() {

	// Until we get the end of our stream we'll show each token.
	for c.token.Type != token.EOF {
		fmt.Printf("%v\n", c.token)
		c.readToken()
	}
}

// Compile process the stream of tokens from the lexer and builds
// up the bytecode program.
func (c *Compiler) Compile() {
	// Until we get the end of our stream we'll process each token
	// in turn, generating bytecode as we go.
	for c.token.Type != token.EOF {
		// Now handle the various tokens
		switch c.token.Type {

		case token.LABEL:
			// Remove the ":" prefix from the label
			label := strings.TrimPrefix(c.token.Literal, ":")
			// The label points to the current point in our bytecode
			c.labels[label] = len(c.bytecode)

		case token.EXIT:
			c.exitOp()

		case token.INC:
			c.incOp()

		case token.DEC:
			c.decOp()

		case token.RANDOM:
			c.randOp()

		case token.RET:
			c.retOp()

		case token.CALL:
			c.callOp()

		case token.IS_INTEGER:
			c.isIntOp()

		case token.IS_STRING:
			c.isStrOp()

		case token.STRING2INT:
			c.str2IntOp()

		case token.INT2STRING:
			c.int2StrOp()

		case token.SYSTEM:
			c.systemOp()

		case token.CMP:
			c.cmpOp()

		case token.CONCAT:
			c.concatOp()

		case token.DB:
			c.dataOp()

		case token.DATA:
			c.dataOp()

		case token.TRAP:
			c.trapOp()

		case token.JMP:
			c.jumpOp(opcode.JUMP_TO)

		case token.JMPZ:
			c.jumpOp(opcode.JUMP_Z)

		case token.JMPNZ:
			c.jumpOp(opcode.JUMP_NZ)

		case token.MEMCPY:
			c.memcpyOp()

		case token.NOP:
			c.nopOp()

		case token.PEEK:
			c.peekOp()

		case token.POKE:
			c.pokeOp()

		case token.PUSH:
			c.pushOp()

		case token.POP:
			c.popOp()

		case token.STORE:
			c.storeOp()

		case token.PRINT_INT:
			c.printInt()

		case token.PRINT_STR:
			c.printString()

		case token.ADD:
			c.mathOperation(opcode.ADD_OP)

		case token.XOR:
			c.mathOperation(opcode.XOR_OP)

		case token.SUB:
			c.mathOperation(opcode.SUB_OP)

		case token.MUL:
			c.mathOperation(opcode.MUL_OP)

		case token.DIV:
			c.mathOperation(opcode.DIV_OP)

		case token.AND:
			c.mathOperation(opcode.AND_OP)

		case token.OR:
			c.mathOperation(opcode.OR_OP)

		default:
			fmt.Println("Unhandled token: ", c.token)
		}
		c.readToken()
	}

	// Now fixups any label-names we've got to patch into place.
	for addr, name := range c.fixups {
		value := c.labels[name]
		if value == 0 {
			fmt.Printf("Possible use of undefined label '%s'\n", name)
		}

		p1 := value % 256
		p2 := (value - p1) / 256

		c.bytecode[addr] = byte(p1)
		c.bytecode[addr+1] = byte(p2)
	}
}

// nopOp does nothing
func (c *Compiler) nopOp() {
	c.bytecode = append(c.bytecode, byte(opcode.NOP_OP))
}

// peekOp reads the contents of a memory address, and stores in a register
func (c *Compiler) peekOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	res := c.getRegister(c.token.Literal)

	// now we have a comma
	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	// and a literal
	if c.token.Type != token.IDENT {
		return
	}
	addr := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.PEEK))
	c.bytecode = append(c.bytecode, res)
	c.bytecode = append(c.bytecode, addr)

}

// pokeOp writes to memory
func (c *Compiler) pokeOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	val := c.getRegister(c.token.Literal)

	// now we have a comma
	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	// and a literal
	if c.token.Type != token.IDENT {
		return
	}
	addr := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.POKE))
	c.bytecode = append(c.bytecode, val)
	c.bytecode = append(c.bytecode, addr)
}

// pushOp stores a stack-push
func (c *Compiler) pushOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.STACK_PUSH))
	c.bytecode = append(c.bytecode, reg)
}

// popOp stores a stack-push
func (c *Compiler) popOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.STACK_POP))
	c.bytecode = append(c.bytecode, reg)
}

// exitOp terminates our interpreter
func (c *Compiler) exitOp() {
	c.bytecode = append(c.bytecode, byte(opcode.EXIT))
}

// incOp increments the contents of the given register
func (c *Compiler) incOp() {

	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.INC_OP))
	c.bytecode = append(c.bytecode, reg)
}

// decOp decrements the contents of the given register
func (c *Compiler) decOp() {

	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.DEC_OP))
	c.bytecode = append(c.bytecode, reg)
}

// randOp returns a random value
func (c *Compiler) randOp() {

	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.INT_RANDOM))
	c.bytecode = append(c.bytecode, reg)
}

// retOp returns from a call
func (c *Compiler) retOp() {
	c.bytecode = append(c.bytecode, byte(opcode.STACK_RET))
}

// isStrOp tests if a register contains a string
func (c *Compiler) isStrOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.IS_STRING))
	c.bytecode = append(c.bytecode, reg)
}

// str2IntOp converts the given string-register to an int.
func (c *Compiler) str2IntOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.STRING_TOINT))
	c.bytecode = append(c.bytecode, reg)
}

// int2StrOp converts the given int-register to a string.
func (c *Compiler) int2StrOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.INT_TOSTRING))
	c.bytecode = append(c.bytecode, reg)
}

// systemOp runs the (string) command in the given register
func (c *Compiler) systemOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.STRING_SYSTEM))
	c.bytecode = append(c.bytecode, reg)
}

// isIntOp tests if a register contains an integer
func (c *Compiler) isIntOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(opcode.IS_INTEGER))
	c.bytecode = append(c.bytecode, reg)
}

// callOp generates a call instruction
func (c *Compiler) callOp() {

	// add the call instruction
	c.bytecode = append(c.bytecode, byte(opcode.STACK_CALL))
	// advance to the target
	c.readToken()

	// The call might be to an absolute target, or a label.
	switch c.token.Type {

	case token.INT:
		addr, _ := strconv.ParseInt(c.token.Literal, 0, 64)

		len1 := addr % 256
		len2 := (addr - len1) / 256

		c.bytecode = append(c.bytecode, byte(len1))
		c.bytecode = append(c.bytecode, byte(len2))

	case token.IDENT:

		// Record that we have to fixups this thing
		c.fixups[len(c.bytecode)] = c.token.Literal

		// output two temporary numbers
		c.bytecode = append(c.bytecode, byte(0))
		c.bytecode = append(c.bytecode, byte(0))
	}

}

// trapOp inserts an interrupt call / trap
func (c *Compiler) trapOp() {

	// advance to the target
	c.readToken()

	// The jump might be an absolute target, or a label.
	switch c.token.Type {

	case token.INT:
		addr, _ := strconv.ParseInt(c.token.Literal, 0, 64)
		len1 := addr % 256
		len2 := (addr - len1) / 256

		c.bytecode = append(c.bytecode, byte(opcode.TRAP_OP))
		c.bytecode = append(c.bytecode, byte(len1))
		c.bytecode = append(c.bytecode, byte(len2))
	default:
		fmt.Printf("Fail!")
	}
}

// jumpOp inserts a direct jump
func (c *Compiler) jumpOp(operator int) {

	// add the jump
	c.bytecode = append(c.bytecode, byte(operator))

	// advance to the target
	c.readToken()

	// The jump might be an absolute target, or a label.
	switch c.token.Type {

	case token.INT:
		addr, _ := strconv.ParseInt(c.token.Literal, 0, 64)
		len1 := addr % 256
		len2 := (addr - len1) / 256

		c.bytecode = append(c.bytecode, byte(len1))
		c.bytecode = append(c.bytecode, byte(len2))

	case token.IDENT:

		// Record that we have to fixups this thing
		c.fixups[len(c.bytecode)] = c.token.Literal

		// output two temporary numbers
		c.bytecode = append(c.bytecode, byte(0))
		c.bytecode = append(c.bytecode, byte(0))
	}

}

// memcpyOp inserts a memcopy operation.
func (c *Compiler) memcpyOp() {
	c.readToken()

	one := c.getRegister(c.token.Literal)

	if !c.expectPeek(token.COMMA) {
		return
	}

	c.readToken()
	two := c.getRegister(c.token.Literal)

	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	three := c.getRegister(c.token.Literal)

	// output the bytecode
	c.bytecode = append(c.bytecode, byte(opcode.MEMCPY))
	c.bytecode = append(c.bytecode, one)
	c.bytecode = append(c.bytecode, two)
	c.bytecode = append(c.bytecode, three)
}

// mathOperation handles add/sub/mul/div/etc
func (c *Compiler) mathOperation(operation int) {

	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// dest
	dst := c.getRegister(c.token.Literal)

	// now we have a comma
	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	// and a literal
	if c.token.Type != token.IDENT {
		return
	}
	src1 := c.getRegister(c.token.Literal)

	// and a comma
	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	// and a final literal
	if c.token.Type != token.IDENT {
		return
	}
	src2 := c.getRegister(c.token.Literal)

	c.bytecode = append(c.bytecode, byte(operation))
	c.bytecode = append(c.bytecode, dst)
	c.bytecode = append(c.bytecode, src1)
	c.bytecode = append(c.bytecode, src2)

}

// storeOp handles loading a register with a string, integer, or register,
// or label-address.
func (c *Compiler) storeOp() {
	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	// Now we know where we're storing the thing we need to determine
	// what is being stored: string, integer, register value, or a
	// label address.
	switch c.token.Type {

	case token.STRING:
		// STRING_STORE $REG $LEN1 $LEN2 $STRING
		c.bytecode = append(c.bytecode, byte(opcode.STRING_STORE))
		c.bytecode = append(c.bytecode, reg)

		lens := len(c.token.Literal)
		len1 := lens % 256
		len2 := (lens - len1) / 256
		c.bytecode = append(c.bytecode, byte(len1))
		c.bytecode = append(c.bytecode, byte(len2))

		// output the length
		for i := 0; i < lens; i++ {
			c.bytecode = append(c.bytecode, c.token.Literal[i])
		}
	case token.INT:
		// INT_STORE $REG $NUM1 NUM2
		c.bytecode = append(c.bytecode, byte(opcode.INT_STORE))
		c.bytecode = append(c.bytecode, reg)

		// Convert to low/high
		i, _ := strconv.ParseInt(c.token.Literal, 0, 64)
		len1 := i % 256
		len2 := (i - len1) / 256
		c.bytecode = append(c.bytecode, byte(len1))
		c.bytecode = append(c.bytecode, byte(len2))
	case token.IDENT:
		if c.isRegister(c.token.Literal) {
			// REG_STORE REG_DST REG_SRC
			c.bytecode = append(c.bytecode, byte(opcode.REG_STORE))
			c.bytecode = append(c.bytecode, reg)
			c.bytecode = append(c.bytecode, c.getRegister(c.token.Literal))
		} else {
			// Here we're storing the address of a label.

			// INT_STORE $REG $NUM1 $NUM2
			c.bytecode = append(c.bytecode, byte(opcode.INT_STORE))
			c.bytecode = append(c.bytecode, reg)

			// record that we need a fixups here
			c.fixups[len(c.bytecode)] = c.token.Literal

			// output two temporary numbers
			c.bytecode = append(c.bytecode, byte(0))
			c.bytecode = append(c.bytecode, byte(0))
		}
	default:
		fmt.Printf("ERROR: Invalid thing to store: %v\n", c.token)
		os.Exit(1)
	}
}

// cmpOp handles comparing a register with a string, integer, or register,
// or label-address.
func (c *Compiler) cmpOp() {

	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	// Save the register we're storing to.
	reg := c.getRegister(c.token.Literal)

	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	// Now we know what source register we're comparing we need to see
	// if that comparison is with a string, integer, register value, or a
	// label address.
	switch c.token.Type {

	case token.STRING:
		// CMP_STRING $REG $LEN1 $LEN2 $STRING
		c.bytecode = append(c.bytecode, byte(opcode.CMP_STRING))
		c.bytecode = append(c.bytecode, reg)

		lens := len(c.token.Literal)
		len1 := lens % 256
		len2 := (lens - len1) / 256

		c.bytecode = append(c.bytecode, byte(len1))
		c.bytecode = append(c.bytecode, byte(len2))

		// append the string
		for i := 0; i < lens; i++ {
			c.bytecode = append(c.bytecode, c.token.Literal[i])
		}
	case token.INT:
		// CMP_IMMEDIATE $REG $NUM1 NUM2
		c.bytecode = append(c.bytecode, byte(opcode.CMP_IMMEDIATE))
		c.bytecode = append(c.bytecode, reg)

		// Convert to low/high
		i, _ := strconv.ParseInt(c.token.Literal, 0, 64)

		len1 := i % 256
		len2 := (i - len1) / 256
		c.bytecode = append(c.bytecode, byte(len1))
		c.bytecode = append(c.bytecode, byte(len2))
	case token.IDENT:
		if c.isRegister(c.token.Literal) {
			// CMP_REG REG_DST REG_SRC
			c.bytecode = append(c.bytecode, byte(opcode.CMP_REG))
			c.bytecode = append(c.bytecode, reg)
			c.bytecode = append(c.bytecode, c.getRegister(c.token.Literal))
		} else {
			// Here we're storing the address of a label.

			// INT_STORE $REG $NUM1 $NUM2
			c.bytecode = append(c.bytecode, byte(opcode.CMP_IMMEDIATE))
			c.bytecode = append(c.bytecode, reg)

			// record that we need a fixups here
			c.fixups[len(c.bytecode)] = c.token.Literal

			// output two temporary numbers
			c.bytecode = append(c.bytecode, byte(0))
			c.bytecode = append(c.bytecode, byte(0))
		}
	default:
		fmt.Printf("ERROR: Invalid thing to store: %v\n", c.token)
		os.Exit(1)
	}
}

// concatOp concatenates two string values.
func (c *Compiler) concatOp() {
	c.readToken()

	dst := c.getRegister(c.token.Literal)

	if !c.expectPeek(token.COMMA) {
		return
	}

	c.readToken()
	a := c.getRegister(c.token.Literal)

	if !c.expectPeek(token.COMMA) {
		return
	}
	c.readToken()

	b := c.getRegister(c.token.Literal)

	// output the bytecode
	c.bytecode = append(c.bytecode, byte(opcode.STRING_CONCAT))
	c.bytecode = append(c.bytecode, dst)
	c.bytecode = append(c.bytecode, a)
	c.bytecode = append(c.bytecode, b)
}

// dataOp embeds literal/binary data into the output
func (c *Compiler) dataOp() {
	c.readToken()

	// We might have a string, or a series of ints
	//
	// If it is a string handle that first
	if c.token.Type == token.STRING {
		for i := 0; i < len(c.token.Literal); i++ {
			c.bytecode = append(c.bytecode, c.token.Literal[i])
		}
		return
	}

	//
	// Otherwise we expect a single int
	//
	db := c.token.Literal
	i, _ := strconv.ParseInt(db, 0, 64)
	c.bytecode = append(c.bytecode, byte(i))

	//
	// Loop looking for more data - we don't know how much
	// there might be, but we'll know it is comma-separated.
	//
	for c.peekTokenIs(token.COMMA) {
		// skip the comma
		c.readToken()

		// read the next int
		if c.expectPeek(token.INT) {
			db := c.token.Literal
			i, _ := strconv.ParseInt(db, 0, 64)
			c.bytecode = append(c.bytecode, byte(i))
		}
	}
}

// Handle printing the contents of a register as an integer.
func (c *Compiler) printInt() {

	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	c.bytecode = append(c.bytecode, byte(opcode.INT_PRINT))
	c.bytecode = append(c.bytecode, c.getRegister(c.token.Literal))
}

// Handle printing the contents of a register as a string.
func (c *Compiler) printString() {

	// We're looking for an identifier next.
	if !c.expectPeek(token.IDENT) {
		return
	}

	c.bytecode = append(c.bytecode, byte(opcode.STRING_PRINT))
	c.bytecode = append(c.bytecode, c.getRegister(c.token.Literal))
}

// determinate next token is t or not
func (c *Compiler) peekTokenIs(t token.Type) bool {
	return c.nextToken.Type == t
}

// expect next token is t
// succeed: return true and forward token
// failed: return false and store error
func (c *Compiler) expectPeek(t token.Type) bool {
	if c.peekTokenIs(t) {
		c.readToken()
		return true
	}
	c.peekError(t)
	return false
}

func (c *Compiler) peekError(t token.Type) {
	fmt.Printf("expected next token to be %s, got %s instead", t, c.token.Type)
	os.Exit(1)
}

// Write outputs our generated bytecode to the named file.
func (c *Compiler) Write(output string) {
	fmt.Printf("Our bytecode is %d bytes long\n", len(c.bytecode))
	err := os.WriteFile(output, c.bytecode, 0777)
	if err != nil {
		fmt.Printf("Error writing output file: %s\n", err.Error())
		os.Exit(1)
	}
}

// Output returns the bytecodes of the compiled program.
func (c *Compiler) Output() []byte {
	return c.bytecode
}
